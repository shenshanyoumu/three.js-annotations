# threejs注解版
Three.js 是一款轻量级的<b>3D 渲染库</b>，提供了基于 Canvas、SVG、CSS3D 和 WebGL 等技术实现的渲染能力。

即然是一款商业级的渲染库，则一定包含完整的 3D 可视化要素，即包含 3D 场景、模型、相机、渲染器、坐标系、纹理/材质、着色和光照等。同时 Three.js 还提供了一系列加载器、动画效果和音效等，在代码结构中分目录整理方便开发者查阅。  

<b>题外话</b>：threejs和D3.js都是采用rollup进行打包，但是D3.js采用lerna的多包单体管理，并且D3.js的代码量更多。D3的代码工程化思想，以及处处体现的函数式编程方式值得借鉴；而three.js与echarts的实现风格更接近，都是采用OOP的思想来模块化管理。


## 模块说明  
### core模块
(1) Object3D(**`核心模块`**,难度系数:`3/5`)  
这个模块是threejs的**核心模块**，3D场景中几乎所有要素都继承自该模块。Object3D基类封装了事件分发、向量/矩阵计算，以及旋转位移变换相关(欧拉角、四元数和变换矩阵)的能力。

注意：Object3D基类包含图层属性Layers。图层对象Layers可以分为32个编号，图层对象layers可以控制场景中对象的可见性。场景中模型对象图层必须和相机对象的图层一样，才能被渲染出来。

(2) 事件总线(**`核心模块`**,难度系数:`3/5`)  
Three.js实现了一个简单的事件分发模块，用于充当整个渲染系统的事件总线。

(3) Clock(**`辅助模块`**,难度系数:`3/5`)  
在场景渲染中通过计时器模块来记录场景的渲染和逻辑计算耗时，帮助开发者发现渲染性能问题

(4) 各类Buffer对象(**`核心模块`**,难度系数:`3.5/5`)  
Three.js是对WebGL的封装，其遵循WebGL的各种数据类型声明。三维场景中各种坐标都是TypedArray类型，并且除了很简单的应用可以直接硬编码顶点着色器坐标和颜色值；对于复杂的三维应用，场景中的数据都是通过外部数据源传入WebGL系统的内置BUFFER对象中进行属性绑定

(5) Geometry(**`核心模块`**,难度系数:`4/5`)    
几何模型与Object3D不同在于，几何模型是一种数学抽象并不直接用于场景渲染。其提供了对场景中各种模型的几何计算能力，比如计算法向量、顶点坐标、顶点颜色，以及几何面。除此之外，几何模型还针对模型的形变处理、皮肤数据，以及包围盒/包围球进行数学计算。

(6) InterleavedBuffer(**`核心模块`**,难度系数:`3.5/5`) 
根据WebGL的编程指南，传递给顶点着色器的多个数据集会被attribute修饰的多变量消费。为了简化编程复杂度和提高数据在CPU与GPU的传输效率，可以采用Interleaved方式来编制多种数据为同一个buffer对象中，WebGL系统通过offset+stride来拆分数据并消费 


### Math模块
(1) 数学基础工具(**`核心概念`**,难度系数:`3.5/5`)  
二维向量、三维向量、四维向量在3D渲染系统主要用于对顶点坐标、颜色系统等表示；而3*3矩阵、4*4矩阵主要用于三维场景变换，以及从模型局部坐标空间过一系列矩阵变换得到屏幕显示的像素空间。矩阵的代数运算主要包括矩阵分解、矩阵乘除法，以及矩阵的特征值计算等;  
四元数是对变换矩阵的空间压缩;欧拉角比四元数容易理解，但是需要注意万向节锁问题，即在旋转到特定角度会丢失模型的自由度。

(2) 坐标系(**`核心概念`**,难度系数:`3/5`)  
<b>平面坐标系</b>:基于法向量和平面到原点的垂直距离来唯一确定一个平面;  
<b>球面坐标系</b>:基于球心坐标、球面半径、球面半径与Y轴夹角，以及球面半径在XZ平面的投影与Z轴夹角来共同决定一个唯一的球面;  
<b>射线坐标系</b>:基于射线原点和射线发出方向来唯一确定射线坐标系中的点  
<b>柱面坐标系</b>:基于柱面在ZX屏幕上的截面半径、沿Y轴逆时针旋转弧度，以及柱面高度三个因子来决定柱面模型

(3) 基础图元(**`核心概念`**,难度系数:`3.5/5`)  
射线:与射线坐标系的定义一样，因此射线坐标系可以不需要单独考虑；  
三角形:三角形的法向量、面积计算、质心、重心、外心等；  
平截头面Frustum:正交相机的视觉空间，ThreeJS在进行隐藏面消除时需要考虑给定片元是否在平截面内部；  
包围盒:为了加快三维场景中模型的碰撞检测效率，抽象出包围盒概念。先对每个模型的包围盒进行相交检测，如果包围盒相交才进一步检测模型的碰撞
平面:平面的构造方程

(4) 相交检测算法(**`高级特性`**,难度系数:`3.5/5`)  
三角形与包围盒的相交检测、与线段的相交检测、与射线的相交检测、与平面的相交检测;  
球面图元与包围盒的相交检测、球面图元间的相交检测；  
平截头面检测是否包含坐标点，以及与其他模型的相交检测，主要用于隐藏面消除逻辑;  
平面与线段、球面、包围盒等模型对象的相交检测


(6) 插值算法(难度系数`:4/5`)  
与D3.js大量的插值算法相比，Three.js的插值类型比较少，主要包括线性插值、三次曲线插值、离散采样插值等。在从顶点着色器通过varying修饰的变量将顶点颜色传递给片元着色器之前，webgl系统内部会自动进行一次颜色的线性插值来生成插值后的片元颜色缓冲


### Scene模块(**`核心概念`**,难度系数:`3/5`)   
三维场景对象就是宇宙，包罗万象唯独不包含camera对象。该模块下定义了雾化效果，以及scene作为容器对象继承自Object3D基类。  
场景对象包含的属性包括背景图、雾化效果，以及材质特性来辅助场景中的光照模型

### Camera模块(**`核心概念`**,难度系数:`3.5/5`) 
相机模型继承自Object3D基类，因此具有事件分发、空间变换等能力，相机模型根据处理视场的形式分为透视相机(符合人类观察)、正交相交(设计领域)、立体相机(游戏场景)、阵列相机(多视角的图像合成) 

### Geometries模块(难度系数:`4.5/5`)
该目录定义了一系列常用的基础几何图形，包含线框图形、多面体、圆形、柱面体、球面、文本几何、管道图形、平面几何体，以及torus、Polyhedron、Lathe等复杂常见的图形。除了描述几何体的顶点及顶点索引，还可能顶点法向量列表、纹理的UV映射坐标  

### Lights模块(**`核心概念`**,难度系数:`3.5/5`) 
计算机图形学的难点在于如何精细化描述光照对模型表面着色效果的影响。并且高级的光学理论和模型表面物理特性的计算过程往往过于复杂，因此需要一系列巧妙的算法来平衡渲染性能和渲染质量。  
当然threejs系统暴露给开发者的光照API都比较简洁，通过简短的代码即可实现满足业务需求的光照。但是作为希望进入图形学领域的开发者来说，一定要记住光照过程是非常复杂的！！  
(1)Light基类  
Light基类同样继承自Object3D基类，定义了光学颜色属性、光照强度属性和对阴影的处理。模型表面的着色效果由光色、模型基底色，以及模型表面法向量和光线角度等因素共同决定  

(2)LightShadow  
光线与模型交互可在场景中形成阴影效果，LightShadow类的属性包括相机、视图变换矩阵等。很容易理解，虽然光线和模型交互可以产生阴影效果，但是观察者位置决定了阴影在裁剪空间的表现

(3)AmbientLight环境光照  
环境光照等价于模型表面全方向均匀光照，因此环境光照的着色效果至于光照颜色和模型表面基底颜色相关

(4)DirectionalLight方向光  
典型的方向光是太阳光，即太阳光作为平行光照射到模型表面。模型表面基底色、模型表面粗糙度、模型表面折射率，以及模型表面法向量和入射光夹角等共同作用影响最终着色

(5)PointLight点光源  
实际应用中可以将室内白炽灯抽象为点光源，点光源与模型表面距离、光照强烈衰减率，光照夹角和模型表面法向量等因素共同决定模型表面着色效果

### Textures纹理(**`核心概念`**,难度系数:`4/5`)  
纹理贴图用于增强三维场景的表现力，纹理贴图对象原型继承自EventDispatch类，具有事件分发能力。因此在完成纹理贴图时可以触发场景更新逻辑，针对多样化的三维场景，纹理贴图从简单的ST贴图到复杂的各向异性贴图都有实现。  

(1)VideoTexture  
视频贴图，即将视频信息贴图到模型表面。在WebGL底层实际上是对视频帧贴图到模型表面并通过eventDispatch事件分发来触发场景渲染更新  

(2)CubeTexture  
立体贴图默认采用环境反射贴图，比如在场景中的镜面反射环境信息时的贴图。其实现方式是采用六个平面图像形成天空盒模型  

(3)DataTexture  
所谓数据贴图，依赖于数据类型和数据格式的贴图方式。如果数据类型为THREE.unsignedByteType，则使用uint8Array声明纹素数据  

(4)CanvasTexture  
所谓canvas贴图，即使用canvas对象绘制图像并作为纹理来源贴图到模型表面





